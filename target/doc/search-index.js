var N=null,E="",T="t",U="u",searchIndex={};
var r_aa="stack_dst",r_ba="result",r_ca="self",r_da="option",r_ea="try_from",r_fa="borrow",r_ga="try_into",r_ha="type_id",r_ia="typeid",r_ja="borrow_mut",r_ka="ValueA",r_la="StackA";

searchIndex[r_aa]={"doc":"Support for storing dynamically-sized types on the stack","i":[[3,r_ka,r_aa,"Stack-allocated dynamically sized type",N,N],[3,r_la,E,"A fixed-capacity stack that can contain dynamically-sized…",N,N],[11,"new",E,"Construct a stack-based DST",0,[[[U]],[r_ba,["valuea"]]]],[11,"new",E,"Construct a new (empty) stack",1,[[],["stacka"]]],[11,"is_empty",E,"Tests if the stack is empty",1,[[[r_ca]],["bool"]]],[11,"push",E,"Push a value at the top of the stack",1,[[[r_ca],[U]],[r_ba]]],[11,"top",E,"Returns a pointer to the top item on the stack",1,[[[r_ca]],[r_da]]],[11,"top_mut",E,"Returns a pointer to the top item on the stack…",1,[[[r_ca]],[r_da]]],[11,"pop",E,"Pop the top item off the stack",1,[[[r_ca]]]],[11,"push_str",E,"Push the contents of a string slice as an item onto the…",1,[[[r_ca],["str"]],[r_ba]]],[11,"push_cloned",E,"Pushes a set of items (cloning out of the input slice)",1,N],[6,"Value",E,"Stack-allocated DST (using a default size)",N,N],[8,"DataBuf",E,"Trait used to represent the data buffer for StackDSTA.",N,N],[11,"from",E,E,0,[[[T]],[T]]],[11,"into",E,E,0,[[[r_ca]],[U]]],[11,r_ea,E,E,0,[[[U]],[r_ba]]],[11,r_fa,E,E,0,[[[r_ca]],[T]]],[11,r_ga,E,E,0,[[[r_ca]],[r_ba]]],[11,r_ha,E,E,0,[[[r_ca]],[r_ia]]],[11,r_ja,E,E,0,[[[r_ca]],[T]]],[11,"from",E,E,1,[[[T]],[T]]],[11,"into",E,E,1,[[[r_ca]],[U]]],[11,r_ea,E,E,1,[[[U]],[r_ba]]],[11,r_fa,E,E,1,[[[r_ca]],[T]]],[11,r_ga,E,E,1,[[[r_ca]],[r_ba]]],[11,r_ha,E,E,1,[[[r_ca]],[r_ia]]],[11,r_ja,E,E,1,[[[r_ca]],[T]]],[11,"drop",E,E,0,[[[r_ca]]]],[11,"drop",E,E,1,[[[r_ca]]]],[11,"default",E,E,1,[[],[r_ca]]],[11,"deref",E,E,0,[[[r_ca]],[T]]],[11,"deref_mut",E,E,0,[[[r_ca]],[T]]]],"p":[[3,r_ka],[3,r_la]]};
initSearch(searchIndex);addSearchOptions(searchIndex);